## n个骰子的和

### 题目

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

```
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

题目网站：https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/

### 解题过程

这题啊，这题很妙。

1. 首先这是一个典型的动态规划。
   然后第n个骰子总和数Si的概率等于第n-1个骰子总和数（Si-1，Si-2，....)前6个数的总和乘以1/6，因此得到了动态方程。f(n,x)=i=1∑6f(n−1,x−i)×61

2. 但这里有一个问题，取前面6个数的时候有可能会超出边界。
   比如2个骰子，数字3的和。按理来说应该是1个骰子，数字2，1，0，-1....6个数的总和再乘以1/6，但0，-1，-2等显然取不到。因此这个方法要处理边界情况，略显蛮烦。（此方法为逆向）
3. 所以可以换一个思路（此方法为正向），第n-1的骰子，Si的概率会影响，第n个骰子，Si+1，Si+2，Si+3...
   的概率。因此可以得到正向递推公式。

```c++
//前一个骰子的概率
for(int j = 0; j < dp.size() ;j++){
       for(int k = 0; k < 6; ++k){
           //当前骰子的概率
          tempRes[j+k] += dp[j] / 6.0;
      }
}
```

![image-20211221224522437](https://gitee.com/MeguminMO/drawing-bed/raw/master//typora/202112212245606.png)

