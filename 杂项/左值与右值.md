# 关于左值和右值的理解

**一个简单的定义**：在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）

1. 纯右值指的是临时变量值、不跟对象关联的字面量值。
2. C++11中的将亡值是随着右值引用的引入而新引入的。换言之，“将亡值”概念的产生，是由右值引用的产生而引起的，将亡值与右值引用息息相关。这样表达式通常是将要被移动的对象（移为他用）
   - 返回右值引用的函数的调用表达式
   - 转换为右值引用的转换函数的调用表达式

**一个简单的归纳**：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的 时候，用的是对象的身份（在内存中的位置）

### 右值引用

 所谓右值引用就是必须绑定到**右值**的引用。（这并不是废话，好好理解）

**返回左值引用的函数**：赋值、下标、解引用和**前置递增/递减运算符**，都是返回左值的表达式的例子。

**返回非引用类型的函数**：连同算术、关系、位以及**后置递增/递减运算符**，都生成右值。 我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个c o n s t 的左值引用或 者一个右值引用绑定到这类表达式上。

**举例：**

一元运算符‘*’（解引用）拿一个右值作为参数而产生一个左值作为结果。

```c++
int arr[] = {1, 2};
int* p = &arr[0];
*(p + 1) = 10;    //对的：p+1是一个右值，但是*(p+1)是一个左值
```

一元取地址符 ‘&’ 拿一个左值作为参数并且生成一个右值：

```c++
int var = 10;
int* bad_addr = &(var + 1); //错误：‘&’运算符要求一个左值
int* addr = &var;           //正确：var是左值
&var = 40;                  //错误：赋值运算符的左操作数要求一个左值
```



### Move

将左值强制转换为右值

`std::move` 是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。

相当于告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。