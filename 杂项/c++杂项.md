## c++杂项

1. 对一个运算符函数来说，它或者是类的成员函数，或者至少含有一个类类型的参数。

2. 当一个重载的运算符是成员函数时，this绑定到左侧运算对象成员运算符 函数的（显式）参数数量比运算对象的数量少一个

3. 不能被重载

   ```c++
   ::	.*	.	? : 
   ```

4. 重载输入运算符时，要处理输入可能失败的情况

5. 重载自增或者自减的时候，要区分前置与后置的区别。为了解决这个问题，后置版本接收一个额外的int类型形参。当我们使用后置版本时，编译器会提供一个0的实参。（前置版本需要安全检查）

6. 如果类定义了调用运算符，则该类的对象称作函数对象

7. `int（int,int)`是一种函数类型，接受2个int，返回一个int

8. 标准库function类型。`function<int(int,int)>`可以表示任意接受两个int，返回一个int的调用对象。可以是函数指针，可以是lamda，可以是函数对象。

9. 可以使用final 来防止继承的发生

10. 当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用。

11. 如果基类的拷贝构造，拷贝赋值，或者移动构造等是被删除的或不可访问的，那么它在派生类的时候也是被删除的。

12. 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析 构函数所属类型相对应的虚函数版本。

13. 当一个基类构造函数含有默认实参（参见6 . 5 . 1 节，第2 1 1 页）时，这些实参并不会 被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分別省略掉一•个含 有默汄实参的形参。例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含 有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（没有默认实参）, 另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。

14. 函数模板

    ```c++
    template<typename T>
    int compare(const T& v1,const T& v2){
    	return v1 > v2 ? 0 : 1;
    }
    ```

    同时也可以使用非类型模板参数

    template<unsigned N, unsigned M> 。传入的参数可以是字面常量

15. 类模板需要显示的提供模板参数类型，在模板名后的尖括号中提供额外信息。

16. 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参

17. 模板参数也可以拥有默认参数

18. 模板只有在使用时才会进行实例化，这意味着，相同的实例可能出现在多个对象文件中。但我们可以通过显示实例化来避免这种开销。（可以有多个声明，但只有一个定义）

    ```c++
    extern template declaration
    template declaration
    ```

19. 在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数

20. 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。

21. 模板函数也可以显示指定模板实参

    ```c++
    template<typename T1,typename T2,typename T3>
    T1 sum(T2,T3);
    ```

    由于T1不在参数列表中，所以无法推导出来，因此需要显示指定

    ```c++
    auto val = sum<long>(100,200);
    ```

22. 当我们无法确定函数的返回类型时，可以使用尾置返回类型。

    ```c++
    template<typename T>
    auto func(T begin, T end) ->decltype(*beg){
    	return *beg;
    }
    ```

23. 如果一个函数的参数类型是const T&，则它可以绑定任何类型的实参（对象或者字面常量）

24. **引用折叠**，如果我们间接创建一个引用的引用，这些引用形成了“折叠”，引用会折叠成一个普通的左值引用类型。（右值也同样适用）

25. 如果一个函数参数是指向模板参数类型的右值引用（如，T&& ）,则可以传递 给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例 化为一个普通的左值引用

26. 如果一个函数参数是指向模板类型参数的右值引用（如T & & ） , 它对应的实参 的const属性和左值/右值属性将得到保持

27. **参数包**，我们用class...或typename...来表示参数包。

    - 模板参数包

      ```c++
      template<typename T,typename... args >
      ```

    - 函数参数包

      ```c++
      void fun(const T&t,const Args&... rest)
      ```

    - 可以使用sizeof来查看包里有多个参数。
    
28. tuple<>（元组）可以存任意多个不同类型的对象，一般用来从一个函数返回多个值。

29. `bitset<31> bit(1u)` 编号0为低位，31为高位。

30. regex 正则表达式

    1. regex_search 寻找第一个与正则表达式匹配的子序列
    2. regex_search(seq,m,r,mft)(字符串，存放结果，正则，可选)
    3. smatch result （用来存放搜索结果）

31. 生成随机数

    1. ![image-20220110162510778](https://gitee.com/MeguminMO/drawing-bed/raw/master//typora/202201101625359.png)
    2. 我们说的随机数发生器，通常是指**分布对象和引擎对象**
    3. cmath.h ----lround函数（四舍五入）

32. 操作符可以用来修改流的格式状态

    1. boolalpha（改变bool值，是打印1，2还是打印字符串）
    2. showbase（显示打印的进制）
    3. ![image-20220110164354551](https://gitee.com/MeguminMO/drawing-bed/raw/master//typora/202201101643219.png)
    4. seek和tell可以用来重定位
       1. seek（重定位位置）
          1. seekg（输入流中使用）(get)
          2. seekp(输出流中使用)(put)
       2. tell(返回当前位置)
          1. tellg(输入流中使用)
          2. tellp(输出流中使用)

33. try()..catch() 会逐层向往查找合适的catch。这个过程称为栈展开。越专门（低端）的catch要放在前面，因为程序不会去查找最优catch。

34. catch（...）可以捕获所有异常

35. noexcept 可以分为说明符或者运算符

    1. `void f() noexcept{}` 和 `noexcept(f()) == true` 都代表承诺f不会抛出异常
    2. 异常是一个类，可以被继承，最基础的类是exception

36. 命名空间可以是不连续的比如 

    ```c++
    namespace bookShop{ 
    	class bookA;
    	class bookB;
    }
    ```

    如果我之前没有定义过bookShop,则就重新定义一个命名空间。如果我之前定义过，就打开命名空间添加两个类。

37. 未命名的命名空间中定义的变量拥有静态生命周期。但仅在文件内部有效。不能横跨多个文件。

38. 不要乱用using

39. 虚继承可以完成菱形继承。多重继承就是继承多个基类。

40. 当一个类有虚继承的基类的时候，它会先去构造它的虚基类，然后才去构造它的直接基类。

41. new 表达式实际上执行了三步操作

    1. 调用operator new（分配一块足够大的，原始的内存空间）
    2. 运行相应的构造函数并传入初始值
    3. 返回指向该对象的指针

42. 定位new new(place_address) type (initializers) 可以在place+address地址中构造函数，并传入initializer 初始化列表

43. typeid (RTTI)(运行时内存识别)

44. 限定作用域的枚举类型 `enum class myFreind{a,b,c}`

45. 不限定作用域的枚举类型 `enum class myFreind : int {a,b,c}`

    1. 如果是不限定作用域的必须指明成员类型。

46. 匿名Union是一个未命名的union，在其所定义的作用域内，该union的成员都是可以直接访问的。

47. 顶层const 指的是靠近指针的const。底层const修饰的是指针指向的变量

### 遵循基类的接口

每个类负责定义各自的接口。因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在**派生类构造函数体内给它的公有或受保护的基类成员赋值**，但是最好**不要这么做**。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始 化那些从基类中继承而来的成员。

### 类型转换运算符

1. 隐式
   - `operator type() const;`
   - 类型转换可以面向任意类型进行定义（除了void）![image-20220106152248521](https://gitee.com/MeguminMO/drawing-bed/raw/master//typora/202201061523932.png)
2. 显示
   - `explicit operator int() const {return val;}`



### 关于单例

1. 分为懒汉式和饿汉式

   1. 饿汉式是天然线程安全的

   2. 懒汉式可以通过双重加锁来实现线程安全。

      ```c++
      Class A{
          private A(){};
          private static A* _instance;
          public static A* getInstance(){
              if(_instance == null){
      		mutex.lock();
               if(_instance == null){
                   _instance = new A();
      		 }
                mutex.unlock();
              }
              return _instance;
          }
      }
      ```

   3. 这里的锁指的是`_instance == null`,第一重锁作用：避免造成大量线程阻塞，避免性能消耗。
       第二重锁作用：避免 instance== null时，第一个线程实例化后，进入阻塞状态的线程被唤醒后仍会进行实例化。

