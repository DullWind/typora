# Effective c++

客户（client）是指某人或某物。他使用你写的代码（通常是一些接口）。在某个时间点你几乎必然发现，你就你自己的客户。那个时候你很很高兴你在**开发接口时把客户放在心上**。

### 1. 视c++ 为一个语言联邦

1. c
2. object-oriented C++
3. Template c++
4. STL

### 2.尽量以const，enum，inline 替换#define 

1. 每个函数的声明揭示其签名式（signature），也就是参数和返回类型。

2. 如果编译器不允许“static 整数型class 常量”完成“in class ”初值设定。可以改用“the enum hack"补偿做法。

   ```c++
   class MyClass{
   	enum {
   		num = 6;
   	}
   	int m_scores[num];
       int m_a;
       char m_c;
   }
   ```

### 3.尽可能使用const

1. 两个函数如果只是常量（constness）不同，也可以被重载。
2. const 成员函数调用non-const成员函数是个糟糕的选择（const 承诺了不会改变其内部数据）。但反过来却可以。（通过两次转型动作）

### 4.确定对象被使用前已被初始化

1. 对象成员变量的初始化动作发生在进入构造函数前。

2. 推荐在构造函数时使用初始值列表**初始化**，而不是在构造函数里**赋值**。（同时初始值列表列出的成员变量，最好与他们在class中声明的顺序相同）

   ```c++
   MyClass::MyClass(int a,char c):m_a(a),m_c(c){}
   ```

3. 如果一个值是const或references,则必须使用初始值列表初始化。

4. non-local staic(extern 声明的变量）可能会有初始化顺序的问题。推荐使用local staic。 

## 构造/析构/赋值运算

### 5.了解c++默认编写并调用了哪些函数

1. 构造
2. 析构
3. 拷贝构造
4. 赋值构造  

### 6.若不想使用编译器自动生成的函数，就该明确拒绝

### 7.为多态基类声明virtual析构函数

1. 不是所有基类的设计都是为了多态，有可能是为了屏蔽拷贝构造函数（P39）

### 8.别让异常逃离析构函数(不甚理解)

1. `std::abort()`结束进程
2. 析构函数不应该抛出异常。可以选择捕捉他们然后当做没看见或者直接结束程序。`try{}catch(){}`
3. 如果客户需要对某个操作运行期间抛出异常做出反应，应该提供一个普通函数执行这个操作，而非放在析构函数中

### 9.绝不在构造函数和析构函数中调用virtual函数

### 10.令operator= 返回一个reference to *this

### 11.在operator= 中处理“自我赋值”

一般发生在一个类中有个类类型

1. 比较是否是同一地址
2. 合适的语句顺序
3. copy-and-swap(通过值传递和swap实现)

### 12.复制对象时勿忘记复制其每一个成分

1. 复制所有local 成员变量
2. 如果基类的拷贝函数是自己定义的，在子类中也请显示的调用他们。
3. 不要尝试拷贝构造和拷贝赋值互相调用。

## 资源管理

### 13.以对象管理资源

资源指的是，一旦你用了它，将来必须还给系统。比如说，内存，互斥锁，网络socket，数据库连接，以及图形界面中的字型和笔刷。（后面几个都不懂）

1. 将资源的管理权限移交给对象而不是程序员。有个具体的例子就是智能指针（shared_ptr 和auto_ptr）。当它离开它的作用域时，它会自动销毁它指向的对象。就避免了内存泄漏的可能。 
2. 获得资源后立刻放进管理对象。资源取得时便进行初始化。在离开时得到释放（RALL）
3. 管理对象运用析构函数确保资源被释放。

指针在销毁时不会释放其所指向的资源，但对象销毁时会调用其析构函数。

### 14.在资源管理类中小心copying行为

1. RALL拷贝时记得使用深拷贝
2. copying 有三种选择
   1. 禁止拷贝
   2. 施行引用计数
   3. 使用智能指针shared_ptr(ptr,destruct)。它允许自定义析构函数。

### 15.在资源管理类中提供对原始资源的访问

1. apis往往要求取地原始资源，因此每个RALL class 都应该提供一个“取得其所管理资源”的办法。
2. 对资源的访问有显示转换和隐式转换两种选择。

### 16.成对使用new 和 delete 时要求采取相同的形式

1. 注意区分delete 和 delete[]
2. 如果你在创建对象时使用，new的表达式中使用[],则在delete中也需要使用[]；

### 17. 以独立语句将newed对象置于智能指针内

1. 如果不这么，一旦异常抛出，会有内存泄漏的风险。（编译器在执行参数列表里的函数时的顺序不是一定的）

## 设计与声明

### 18.让接口更容易被使用

1. 好的接口容易被正确使用，不易被误用（如果某个客户企图使用某个接口却没有获得他所预期的行为，这个代码不该通过编译）
2. 正确使用
   1.  接口一致性（比如c++的STL容器都有一个size（）方法，不像其他语言有的是length，count，length（）。。。）
   2. 与内置类型的兼容（如果重载 * ，返回的是一个const ，可以阻止 a * b = c）的发生。
3. 阻止误用
   1. 建立新类型，限制类型
   2. 消除客户的资源管理责任（RALL）
   3. shared_ptr 支持定制性删除器。可以防止dll问题。

### 19.设计class犹如设计type

1. 新的type的对象应该如何被创建和销毁
2. 对象的初始化和对象的赋值该有什么样的差别
3. 新type的对象如果被passed by value,意味着什么
4. 什么是新type的”合法值“
5. 你的新type需要配合某个继承图系
6. 你的新type需要什么样的类型转换
7. 什么样的操作符和函数对此新type而言是合理的
8. 什么样的标准函数应该被驳回
9. 谁该取用新type的成员
10. 什么是新type的”未声明接口“
11. 你的新type有多么一般化
12. 你是否真的需要一个type

### 20.多用引用传递代替值传递

1. 这一条规则对内置数据类似不管用

### 21.必须返回对象时，别妄想返回其reference

1. 不要返回一个指针或者引用指向一个栈内对象。
2. 不要返回一个引用指向堆对象。
3. 不要返回一个指针或引用指向local static 对象（当可能有多个这个对象时）

### 22.将成员变量声明为private

1. 为了封装性。可以赋予客户访问数据的一致性。细微划分访问控制，允许约束条件以获得保证，并提供class作者以充分的实现弹性。
2. protected 不比public 更有封装性

### 23. 宁以non-member,non-freiend 替换 member 函数（在可以实现相同功能的前提下）

1. 这样做可以增加封装性，包裹弹性和机能扩充性
2. 选择non-member并不会增加“能够访问class内之private成分“的函数数量
3. 越多函数可以访问私有的数据，数据的封装性越低。
4. 封装：意味着我们能够改变事物而只影响有限客户 。

### 24.若所以参数都需要类型转换，请采用non-member函数

1. 因为成员函数会隐身传递一个this指针，这个指针无法发生隐式类型转换。所以需要声明为非成员函数。

### 25.考虑写出一个不抛异常的swap函数

1. swap 主要有两个职责

   1. 提供便捷高效的置换两个值
   2. 帮助class提供异常安全性保障

2. c++ 内置版本的定义

   ```c++
   namespace std{
   	template<typename T>
       void swap(T& a ,T& b){
           T temp(a);
           a = b;
           b = temp;
       }
   }
   ```

3. 如果你嫌以上函数效率不高，你可以自己定义一个swap成员函数，但要确保不会抛出异常。

4. 如果你提供了一个member swap。也要提供一个non-member swap  来调用前者。如果参数类型是class ，请提供特化 std::swap。如果不是直接覆盖它就好（**注意：**不能再全局空间内直接定义，c++委员会不允许我们改变std命名空间内的东西，因此我们可以自己定义一个命名空间，然后重载swap）。

5. 调用swap时应针对std::swap 使用using 声明式(不能直接调用std::swap。因为这样会显示强制调用std里的swap),然后调用swap。

6. 对类类型进行std templates 全特化是好的，但不要在std里加入全新的东西。

## 实现

### 26.尽可能延后变量定义式的出现时间

1. 当你确定需要用到变量时再定义。

### 27.尽量少做转型动作

1. c++ 有四种新的转型动作
   1. const_cast<T> (expression)  // c++里唯一用来从const 转为非const 的类型转换。
   2. dynamic_cast<T>(expression) //安全向下转型
   3. reinterpret_cast<T> (...) //执行低级转型
   4. static_cast<T>(...) //强迫隐式转换
2. 类型转换实际上会改变内存数据。比如int转double
3. 如果转型是必要的，试着将它隐藏再某个函数后面。
4. 尽量使用c++的类型转换

### 28.避免返回handles指向对象的内部成分

1. handles(号码牌)：reference，指针，迭代器（用来取得某个对象）
2. 这个条框可增加封装性。帮助const成员函数的行为像个const，避免“虚吊号码牌”（空悬指针）的发生。

### 29.为“异常安全”而努力是值得的

1. 两个标准
   1. 不泄漏任何资源
   2. 不允许数据败坏
2. 三个保证（只需提供一个就好）
   1. 基本承诺：异常抛出后，所有对象处于一种前后一致的状态。数据结构不会因此受到破坏。（通常使用以对象来管理数据）
   2. 强烈保证：如果一个函数运行成功那么就成功，如果没有成功，程序会返回调用函数前的状态。（通常使用copy-and-swap,先取得副本然后操作，如果成功就将副本赋值回去）
   3. 不抛掷保证：将一个函数声明为 `int doSomething() throw();` 这并不意味着这个函数不会抛出异常，而是指如果抛出异常，将是严重错误。程序将会退出。
3. 函数中的异常安全等级，取决于函数中异常安全等级最弱的那一个。

###  30.透彻了解inlining的里里外外

1. inline 可以显示定义，在函数前面添加“inline”。也可以隐式定义，直接将函数定于类内。
2. inline并不是强制的，编译器可以选择拒绝。（一般拒绝函数指针，循环，递归或者过于复杂的代码） 
3. 一般将inline 置于头文件内，因为大多数buid environments 在编译过程中进行inlining。

### 31.将文件间的编译依存关系降至最低

1. 主要思想就是，将文件间的依存关系，相依于声明式，不要相依于定义式。由此有两个主要的方法。
   1. **Handle classes**:定义两个接口一模一样的文件。主文件内会多一个指针成员（最好是share_ptr）指向其具体实现类。这种设计通常被称为**pimple idiom**（pointer to implementation(实现) 	语法）。这个类通常称为Handle classes。这样就能实现，**接口与实现的分离**。
   2. Interface classes：有一个抽象基类，这个基类提供一个静态方法创建一个指向子类对象的基类指针。
   3. 以上两种方法都可以降低接口与实现的耦合。但也会有些额外的开销，比如handle classes 需要进行一次额外的跳转，interface classes 需要维护vptr，以及虚表。但这些都是小问题。
   4. 最后，以上这些操作都不应该是inline 操作，因为一旦inline 的函数发生变化，所有调用inline函数都要重新编译。
2. 程序库头文件应该以“完全且仅有声明式”的形式存在。

### 32.确定你的public继承塑膜出is-a 关系

1. is-a 是一种关系，代表着一种“是”的关系，比如class d("derived") 继承自 class B("Base")。意味着d 就是 B，B可以干的事情，d都可以干。但d可以干的事情，b不可以干。
2. 以上那个关系不能想当然。比如正方形就不能public 继承矩形，因为正方形的长等于宽，我们不能做到只增加他的长，而不增加它的宽。但矩形可以。

### 33.避免遮掩继承而来的名称

1. 派生类中的名称会遮掩base classes 内的名称（就算名称不一样也会遮掩，或者叫覆盖），在public继承下没有人希望如此
2. 为了解决遮掩问题可以使用using声明式，或者转交函数。
3. 说句题外话：不管派生类是怎么继承基类，只要基类成员是public 或者 protect ，派生类就可以访问（private的话派生类也不可以访问）。继承方式改变的只是类外对象访问基类成员的方式。

### 34.区分接口继承和实现继承

1. 纯虚函数意味着指定接口继承
2. 虚函数意味着提供指定接口继承以及默认的实现继承
3. 非虚函数意味着实现继承

### 35.考虑virtual 函数以外的其他选择

如果某个类重载了他的调用符，那么他就是函数对象。它可以拥有自己的的状态，在类中定义状态变量。函数对象可以有自己特有的类型。（可以被继承）

1. virtual函数的替代方法有多种
   1. NVI（non-virtual interface）,也叫做 Template Method （模板模式），跟c++ 的template 没什么关系。声明一个私有的虚函数，然后通过一个公共的函数调用它（就是将一个函数具体的实现延迟到子类）。
   2. 通过Stratery（策略模式）来代替
      1. 将函数从类内抽离出来进行封装成一个对象（可以被继承）。当需要使用时把对象做为参数重新传入就好。
      2. 将虚函数替换为“函数指针成员变量”
      3. 通过tr1::function 来替代
         - (tr1::function)它能接受任何可调用物，只要可调用物的的签名式兼容于需求端即可
         - 它可以调用bind来绑定不同的对象
2. 将成员函数移到类外部会带来一个问题，非成员函数无法访问类的保护和私有成员。当然你可以把它声明为友元函数，但这样的话就破坏对象的封装性。

### 36.绝不重新定义继承而来的non-virtual 函数

### 37. 绝不重新定义继承而来的缺省参数值

1. 静态类型：声明时所用的类型
2. 动态类型：目前所指对象的类型
3. 缺省参数值都是静态绑定的，但virtual函数却是动态绑定的。因此如果你重新定义了缺省的参数值就会导致，运行函数的时候，调用的是派生类的函数，但参数值却是基类的。

### 38.通过复合塑模出has-a 或“根据某物实现出”

1. 复合的意义和public 继承完全不一样。
2. 在应用域，复合意味着has-a(有一个)。在实现域，复合意味着is-implemented-in-terms-of（根据某物实现出）。
   - 应用域：你所塑造世界中的某些东西（人，汽车，视频等等）
   - 实现域：用于实现对象的某些细节（缓冲区（buffer），互斥器（mutexes））

### 39.明智而审慎地使用private继承

及时一个virtual 函数是私有的，派生类仍然可以重新定义它。

1. private 继承意味着is-implemented-in-terms-of(根据某物实现出)。它通常比复合的使用级别低（当你不确定要使用复合还是private的使用，就使用复合）。有两种情况下使用private是合理的

   1. 当derived class 需要访问基类的protect 成员的时候
   2. 需要重新定义基类的虚函数的时候。（可以选择重新新建一个专门的类public继承自基类，然后当前类私有的拥有新建的这个类）（复合+继承）

2. 和复合不同，private 继承可以造成empty base 最优化。比如

   ```c++
   class A{} //空类
   class B{
   	int i;
   	A a;
   } // 对象的大小会超过1
   class C : private A{
       int i;
   }// 对象大小等于4；
   ```

   这个就叫做EBO（empty base optimization）空白基类最优化

### 40.明智而审慎地使用多重继承

1. 多重继承比较复杂可能导致新的歧义性，以及对virtual继承的需要。
2. virtual 继承会增加各种成本（大小，初始化）（比如说当创建一个派生类对象的时候最先调用的是virtual基类的构造函数，然后才是自身的），最好virtual 不带有任何数据。
3. 多重继承某些时候确实有用，但尽量少用。







​                                                                                                         
