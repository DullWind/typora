## 杂项

1. 对一个运算符函数来说，它或者是类的成员函数，或者至少含有一个类类型的参数。

2. 当一个重载的运算符是成员函数时，this绑定到左侧运算对象成员运算符 函数的（显式）参数数量比运算对象的数量少一个

3. 不能被重载

   ```c++
   ::	.*	.	? : 
   ```

4. 重载输入运算符时，要处理输入可能失败的情况

5. 重载自增或者自减的时候，要区分前置与后置的区别。为了解决这个问题，后置版本接收一个额外的int类型形参。当我们使用后置版本时，编译器会提供一个0的实参。（前置版本需要安全检查）

6. 如果类定义了调用运算符，则该类的对象称作函数对象

7. `int（int,int)`是一种函数类型，接受2个int，返回一个int

8. 标准库function类型。`function<int(int,int)>`可以表示任意接受两个int，返回一个int的调用对象。可以是函数指针，可以是lamda，可以是函数对象。

9. 可以使用final 来防止继承的发生

10. 当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用。

11. 如果基类的拷贝构造，拷贝赋值，或者移动构造等是被删除的或不可访问的，那么它在派生类的时候也是被删除的。

12. 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析 构函数所属类型相对应的虚函数版本。

13. 当一个基类构造函数含有默认实参（参见6 . 5 . 1 节，第2 1 1 页）时，这些实参并不会 被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分別省略掉一•个含 有默汄实参的形参。例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含 有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（没有默认实参）, 另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。

14. 函数模板

    ```c++
    template<typename T>
    int compare(const T& v1,const T& v2){
    	return v1 > v2 ? 0 : 1;
    }
    ```

    同时也可以使用非类型模板参数

    template<unsigned N, unsigned M> 。传入的参数可以是字面常量

15. 类模板需要显示的提供模板参数类型，在模板名后的尖括号中提供额外信息。

16. 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参

17. 模板参数也可以拥有默认参数

### 遵循基类的接口

每个类负责定义各自的接口。因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在**派生类构造函数体内给它的公有或受保护的基类成员赋值**，但是最好**不要这么做**。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始 化那些从基类中继承而来的成员。

### 类型转换运算符

1. 隐式
   - `operator type() const;`
   - 类型转换可以面向任意类型进行定义（除了void）![image-20220106152248521](https://gitee.com/MeguminMO/drawing-bed/raw/master//typora/202201061523932.png)
2. 显示
   - explicit operator int() const {return val;}



### 关于单例

1. 分为懒汉式和饿汉式

   1. 饿汉式是天然线程安全的

   2. 懒汉式可以通过双重加锁来实现线程安全。

      ```c++
      Class A{
          private A(){};
          private static A* _instance;
          public static A* getInstance(){
              if(_instance == null){
      		mutex.lock();
               if(_instance == null){
                   _instance = new A();
      		 }
                mutex.unlock();
              }
              return _instance;
          }
      }
      ```

   3. 这里的锁指的是`_instance == null`,第一重锁作用：避免造成大量线程阻塞，避免性能消耗。
       第二重锁作用：避免 instance== null时，第一个线程实例化后，进入阻塞状态的线程被唤醒后仍会进行实例化。

