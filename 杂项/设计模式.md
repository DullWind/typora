### 设计编程思想

封装，继承，多态

### 设计模式目的

1. 让业务逻辑与界面逻辑分离
2. 实现代码高内聚低耦合

### 几个原则

1. 开闭原则 
   - 是说软件实体（类、模块、函数等等） 应该可以扩展，但是不可修改。即面对需求，
   - 对程序的改动是通过增加新代码进行的，而不是更改现有的代码
   - 开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的 巨大好处，也就是可维护、可扩展、可复用、炅活性好：开发人员应该仅对程序中呈现出频繁变化的那 些部分做出抽象，然而•对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成 熟的抽象和抽象本身一样重要
2. 迪米特法则（最少知识原则） --- 尽量不要让外部的操作者接触到类内的所有东西。最好需要什么就提供一个接口。
3. 合成复用原则 ---  能组合尽量使用组合，少使用继承。
4. 单一职责原则
   - 就一个类而言，应该仅有一个引起它变化的原因
5. 里氏代换原则 --- 多态
   - 子类型必须能够替换掉它们的父类型
6. 依赖倒转原则
   - 高层模块不应该依赖低层模块。两个都应该依赖抽象。
   - 抽象不应该依赖细节。细节应该依赖抽象。
   - 依赖倒转其实可以说是面向对象设计的标志，  用哪种语言来编写程序不重要，如果编写 时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者 接口，那就是面向对象的设计，反之那就是过程化的设计了

### UML类图

![image-20211029112025072](C:\Users\wuyuzhen02\Desktop\typora\杂项\图片\image-20211029112025072.png)

### 简单工厂模式

1. 目的：让业务逻辑与页面逻辑进行分离,通过工厂来创建不同的类，获得不同的产品

2. 代码：实现一个计算机功能

   - ```C++
     class Oper {
     public:
     	virtual int getResult(int a, int b) = 0;
     };
     
     class Add : public Oper {
     	int getResult(int a, int b) {
     		return a + b;
     	}
     };
     
     class Sub:public Oper {
     	int getResult(int a, int b) {
     		return a - b;
     	}
     };
     
     class Mul :public Oper {
     	int getResult(int a, int b) {
     		return a * b;
     	}
     };
     
     class Divi :public Oper {
     	int getResult(int a, int b) {
     		if (b == 0) {
     			cout << "除数不能为0" << endl;
     			return 0;
     		}
     		return a / b;
     	}
     };
     
     class SimpleFactory {
     public:
     	oper* getOper(char a) {
     		switch (a) {
     		case '+':
     			return new add();
     			break;
     		case '-':
     			return new sub();
     			break;
     		case '*':
     			return new mul();
     			break;
     		case '/':
     			return new divi();
     			break;
     		}
     	}
     };
     
     
     
     int main() {
     	int num1, num2;
     	cout << "请输入两个数字,用空格分开" << endl;
     	cin >> num1 >> num2;
     	char tran;
     	cout << "请输入运输符" << endl;
     	cin >> tran;
     
     	SimpleFactory fac = SimpleFactory();
     	oper* oper = fac.getOper(tran);
     	int res = oper->getResult(num1, num2);
     	cout << res << endl;
     
     	return 0;
     }
     ```

     

### 策略模式

1. 策略模式(Strategy)：它定义了算法家族，分别封装起来，让 它们之间可以互相替换，此模式让算法的变化，不会影响到使 用算法的客户。[DP]

2. 其主要功能就是用来**封装算法**，在实际编程过程中需要在不同时间应用**不同的业务规则**，就可以考虑使用策略模式处理 这种变化的可能性。

3. 代码：实现计算器

   1. ```c++
      class Oper {
      public:
      	virtual int getResult(int a, int b) = 0;
      };
      
      class Add : public Oper {
      	int getResult(int a, int b) {
      		return a + b;
      	}
      };
      
      class Sub :public Oper {
      	int getResult(int a, int b) {
      		return a - b;
      	}
      };
      
      class Mul :public Oper {
      	int getResult(int a, int b) {
      		return a * b;
      	}
      };
      
      class Divi :public Oper {
      	int getResult(int a, int b) {
      		if (b == 0) {
      			cout << "除数不能为0" << endl;
      			return 0;
      		}
      		return a / b;
      	}
      };
      
      class SimpleFactory {
      public:
      	Oper* m_oper = nullptr;
      	SimpleFactory(char a) {
      		switch (a) {
      		case '+':
      			this->m_oper = new Add();
      			break;
      		case '-':
      			this->m_oper = new Sub();
      			break;
      		case '*':
      			this->m_oper = new Mul();
      			break;
      		case '/':
      			this->m_oper = new Divi();
      			break;
      		}
      	}
      
      	int getResult(int a, int b) {
      		if (!m_oper) {
      			cout << "未初始化操作类" << endl;
      		}
      		return this->m_oper->getResult(a, b);
      	}
      };
      
      
      
      int main() {
      	int num1, num2;
      	cout << "请输入两个数字,用空格分开" << endl;
      	cin >> num1 >> num2;
      	char tran;
      	cout << "请输入运输符" << endl;
      	cin >> tran;
      
      	SimpleFactory fac = SimpleFactory(tran);
      	int result = fac.getResult(num1, num2);
      	cout << result << endl;
      
      
      	return 0;
      }
      ```

      

### 装饰模式

1. 目的：为已有功能动态的添加更多功能的一种方式
2. 优点：有效的把类的核心职责和装饰功能区分开了。可以去除相关类中重复的装饰逻辑
3. 代码：穿衣服