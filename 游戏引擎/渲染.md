## 渲染

### 游戏的基础渲染

**GPU**

- SIMD（单指令多数据），一个指令可以完成多个运算。
- SIMT（多指令并行），多个小型内核。
- 费米架构（每个不同的核心处理不同的功能）
- ![1652350772317](%E6%B8%B2%E6%9F%93_%E5%9B%BE%E7%89%87/1652350772317.png)
- 数据尽可能单向传递（cpu→gpu）![1652351254886](%E6%B8%B2%E6%9F%93_%E5%9B%BE%E7%89%87/1652351254886.png)
- gpu的性能约束，主要取决于以下方面
  - memory Bounds
  - ALU Bounds
  - TMU（Texture Mapping Unit） Bound
  - BW（Bandwidth) 带框 Bound
- gpu编程的时候，最好写一部分debug一部分。千万不要蒙头写一堆，然后debug不出来错误。

**Mesh Render Component**

- 游戏引擎中可绘制的核心对象
- Mesh Primitive（网格的源数据？）
  - 主要存的是顶点数据和三角形的索引值
  - ![1652351755909](%E6%B8%B2%E6%9F%93_%E5%9B%BE%E7%89%87/1652351755909.png)

1. materials

   - 定义的是物体的表面，比如对光线的吸收，冯模型等
   - 纹理
   - shader

2. submesh

   - 每个大的mesh可以分成多个小的submesh，然后每个submesh只要存一个偏移量就可以实现对一个大模型的细节部分进行渲染
   - ![1652352454155](%E6%B8%B2%E6%9F%93_%E5%9B%BE%E7%89%87/1652352454155.png)

3. Resource Pool

   - 把相同的materia，shader或者texture可以放在一个公共的pool，实现共用。

4. DrawCall

   - 合批处理，对显卡的状态设置预先设置好，然后一次绘制多个object。

**visibility Culling**

   - 对世界中的物体进行裁剪，玩家看不见的物体就不需要渲染。

   - 多种包围盒
   - ![1652353319722](%E6%B8%B2%E6%9F%93_%E5%9B%BE%E7%89%87/1652353319722.png)
   - 对空间进行划分有多种方法
     - BVH（使用较多，方便插入删除）
     - 八叉树
     - PVS
     - 等

5. GPU Culling

   - gpu 会自己进行深度测试。（会根据depthBuffer里的大小来更新frameBuffer）

**Texture Compression**

游戏里面的图片一般不使用jpg，png等压缩，因为无法进行随机查询。但可以使用block Compression（将一个块里的最大值和最小值确定下来，然后其他点存：离最大值和离最小值的比例关系）

![1652354172265](%E6%B8%B2%E6%9F%93_%E5%9B%BE%E7%89%87/1652354172265.png)

**模型管线**

游戏引擎的绘制技术一直是在进步的。

1. Cluster-Based Mesh pipline
   - 确定mesh的块大小
   - gpu可以自己动态的生成几何数据。
   - 根据摄像机的远近生成不同的网格
   - ![1652354561487](%E6%B8%B2%E6%9F%93_%E5%9B%BE%E7%89%87/1652354561487.png)
2. 虚幻的Nanite
   - ![1652354586142](%E6%B8%B2%E6%9F%93_%E5%9B%BE%E7%89%87/1652354586142.png)

**总结**

1. render的最好算法就是do nothing
2. ![1652354673346](%E6%B8%B2%E6%9F%93_%E5%9B%BE%E7%89%87/1652354673346.png)

### 材质，shader，光照

这一部分跟计算机图形学的内容差不多，主要是讲如何将一个物体在光照环境下渲染出来。

文件：[计算机图形学](./计算机图形学/计算机图形学.md)

### 特殊的渲染

### 管线

### 地形

