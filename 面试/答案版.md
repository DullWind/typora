# 答案版

## c++

### 程序的编译过程：

1. 预编译 
   - 宏定义进行替换，处理所有条件预编译指令，如#if,#endif
   - 处理#include预编译指令，将文件内容进行替换
   - 删除注释
   - 保留所有#pragma编译器指令，如#pragma once
   - 添加行号和文件标识
2. 编译
   - 预编译之后会生成xxx.i文件
   - 进行词法分析，语法分析，语义分析，优化，目标代码生成，目标代码优化
3. 汇编
   - 汇编--将汇编代码转变成机器可执行指令，产生目标文件xx.o
4. 链接
   1. 将不同源文件进行链接，从而形成一个可执行文件
   2. 分为静态链接和动态链接

### 程序的内存分配

1. 栈，堆，全局/静态区，常量区，代码区

### 原码，反码，补码

1. 原码：十进制转二进制，得到的就是原码。符号位 + 二进制标识
2. 反码：为了实现，两个相反的数相加等于0
   1. 反码的负数相加出错，其实问题不大。我们只需要加实现两个负数加法时，将两个负数反码包括符号位全部按位取反相加，然后再给他的**符号位强行置‘1’**就可以了。
   2. 表示
      - 正数的反码不变
      - 负数的反码 = 符号位不变 + 其他位取反
3. 补码：
   1. 补码的引入是为了解决减法问题
   2. 表示：
      1. 反码+1
   3. 定义：类似于时钟的原理，10 - 2 = 10 + 10 = 8 点。它之所以等于反码+ 1 ，只是因为正好可以这样算而已。

### new ，delete和 malloc,free

1. new,delete 是操作符，而mallco ,free是函数
2. new 失败会报错,而mallco 是返回空
3. 使用new 时无需指定大小，而mallco 需要
4. new ,delete会调用类的构造函数(析构函数)，而mallco,free不会，因此new 返回的是指定类型的指针，而malloc 需要自己指定
5. malloc,free 支持重载

### 成员函数能不能调用delete this

1. 可以，但调用完以后不能在使用类的数据成员和虚函数

### delete 和 delete[] 区别

	1. delete 用来会调用对象的析构函数
 	2. delete 用来会调用数组中每个对象的析构函数

### vector 和 list的区别

1. vector 底层的实现是数组，list 的底层实现是双向链表
2. vector 是顺序内存,list 是不连续的

### 指针和引用的区别

1. 指针是一个变量，只是指针存储的是一个地址，引用是变量的一个别名
2. 引用不可以为空，没有const 引用
3. sizeof 指针返回的是指针大小，引用返回的是对象大小
4. 指针可以有多级
5. 自增含义不一样

### 四大转换

1. static_cast:强制类型转换
   1. 没有类型检测
   2. 用于类层次中基类和派生类之间指针和引用的类型转换
   3. 基本数据类型之间的转换
   4. 空指针转为目标类型指针
2. dynamic_cast 
   1. 有类型检查
   2. 一般用于基类向派生类之间指针类型转换
3. const_cast
   1. 常量指针转为非常量的指针
   2. 一般用来修改底层指针（const char* p）
4. reinterpret_cast
   1. reinterpret_cast<type-id> (expression)
   2. type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行强制转换。

### 右值引用

1. 右值：与左值相对的概念，c++里的一个表达式的值不是左值就是右值，左值指的是可以拥有名字的变量，比如 int a = 19;a 就是左值，19就是右值。

   1. 纯右值：临时变量，不与对象关联的字面常量
   2. 将亡值：当用一个右值去初始化一个对象时，会调用相应的移动构造函数或者移动赋值函数，同时该右值会被马上销毁。这就是将亡值。

2. 当一个对象被用作右值时，用的是对象的值。当被用作左值时，用的是对象的身份（在内存中的位置）

3. 右值引用：必须绑定到右值的引用。

4. move：将一个左值变为一个右值：将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。

   相当于告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。

### 面向对象3个特征

1. 继承：让某种类型对象获得另一个类型对象的属性和方法
2. 封装：数据和代码绑定在一起不受外界干扰，把客观事物封装成抽象的类
3. 多态：重载实现编译时多态，虚函数实现运行时多态

### 构造函数初始化列表和函数体有什么不同

1. 初始化列表会比在函数体内赋值，少调用一次构造函数。

### 智能指针

1. share_ptr: 可以有多个对象拥有这个指针，但会出现循环引用的错误。可以使用weak_ptr 解决
2. unique_ptr: 同时只能有一个unique_ptr指向给定对象，可以通过reset方法重新指定。
3. auto_ptr :RALL思想，通过对象来管理指针。

### c++ 和lua 怎么进行交互

1. c++调用lua

   1. 通过一个虚拟堆栈，lua 提供了c api 来对栈进行操作
   2. 函数调用流程是先将函数入栈，参数入栈，然后用lua_pcall调用函数，此时栈顶为参数，栈底为函数，所以栈过程大致会是：参数出栈->保存参数->参数出栈->保存参数->函数出栈->调用函数->返回结果入栈。

2. lua调用c++

   1. 注意：函数要遵循规范,要接收一个lua_state作为参数,同时返回一个整数（lua可以有多个返回值）
   2. 将函数写入lua.c中，然后重新编译lua文件
   3. 静态依赖的方式：在vc++目录中，把lua中的头文件和lib文件的目录包含进来，然后->链接器->附加依赖项->将lua51.lib和lua5.1.lib也包含进来。
   4. 大概顺序是：我们在c++中写一个模块函数，将函数注册到lua解释器中，然后由c++去执行我们的lua文件，然后在lua中调用刚刚注册的函数

3. 总结：lua和c++是通过一个虚拟栈来交互的。

   c++调用lua实际上是：由c++先把数据放入栈中，由lua去栈中取数据，然后返回数据对应的值到栈顶，再由栈顶返回c++。

   lua调c++也一样：先编写自己的c模块，然后注册函数到lua解释器中，然后由lua去调用这个模块的函数。

### 手写单例

```c++
 mutex mtx;
    class MyClass {
        static MyClass* _instance;
        static MyClass* getInstance() {
            if (_instance == nullptr) {
                mtx.lock();
                if (_instance == nullptr) {
                    _instance = new MyClass();
                }
                mtx.unlock();
            }
            return _instance;
        }
    private:
        MyClass() {};
    };
```



