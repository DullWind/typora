// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

CCEffect %{
  techniques:
  - passes:
    - vert: vs
      frag: fs
      blendState:
        targets:
        - blend: true
      rasterizerState:
        cullMode: none
      properties:
        texture: { value: white }
        alphaThreshold: { value: 0.5 }
        glowColorSize: {value: 0.5, editor: { range: [0,1,0.01], slide: true ,tooltip: '发光宽度' }}
        glowColorR: {value: 0.5, editor: { range: [0,1,0.01], slide: true,tooltip: '红色' }}
        glowColorG: {value: 0.5, editor: { range: [0,1,0.01], slide: true,tooltip: '绿色' }}
        glowColorB: {value: 0.5, editor: { range: [0,1,0.01], slide: true,tooltip: '蓝色' }}
        glowThreshold: {value: 0.5, editor: { range: [0,1,0.01], slide: true,tooltip: '透明度阀值' }}


}%


CCProgram vs %{
  precision highp float;

  #include <cc-global>
  #include <cc-local>

  in vec3 a_position;
  in vec4 a_color;
  out vec4 v_color;

  #if USE_TEXTURE
    in vec2 a_uv0;
    out vec2 v_uv0;
  #endif
  

  void main () {
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_MODEL
    pos = cc_matViewProj * cc_matWorld * pos;
    #else
    pos = cc_matViewProj * pos;
    #endif

    #if USE_TEXTURE
    v_uv0 = a_uv0;
    #endif

    v_color = a_color;

    gl_Position = pos;
  }
}%


CCProgram fs %{
  precision highp float;

  #include <alpha-test>
  #include <texture>

  in vec4 v_color;

  #if USE_TEXTURE
    in vec2 v_uv0;
    uniform sampler2D texture;
  #endif
  uniform Shine{
    float glowColorSize;
    float glowColorR;
    float glowColorG;
    float glowColorB;
    float glowThreshold;
  };
  vec4 glowColor =  vec4(glowColorR,glowColorG,glowColorB,1);

  float getColorAlpha(float angle, float dist) {
    // 角度转弧度，公式为：弧度 = 角度 * (pi / 180)
    // float radian = angle * 0.01745329252; // 这个浮点数是 pi / 180
    float radian = radians(angle);
    vec4 color = texture(texture, v_uv0 + vec2(dist * cos(radian), dist * sin(radian))); 
    return color.a;
  }


  float getAverageAlpha(float dist) {
    float totalAlpha = 0.0;
    // 以30度为一个单位，那么「周边一圈」就由0到360度中共计12个点的组成
    totalAlpha += getColorAlpha(0.0, dist);
    totalAlpha += getColorAlpha(30.0, dist);
    totalAlpha += getColorAlpha(60.0, dist);
    totalAlpha += getColorAlpha(90.0, dist);
    totalAlpha += getColorAlpha(120.0, dist);
    totalAlpha += getColorAlpha(150.0, dist);
    totalAlpha += getColorAlpha(180.0, dist);
    totalAlpha += getColorAlpha(210.0, dist);
    totalAlpha += getColorAlpha(240.0, dist);
    totalAlpha += getColorAlpha(270.0, dist);
    totalAlpha += getColorAlpha(300.0, dist);
    totalAlpha += getColorAlpha(330.0, dist);
    return totalAlpha * 0.0833; // 1 / 12 = 0.08333
  }

  float getGlowAlpha() {
    // 如果发光宽度为0，直接返回0.0透明度，减少计算量
    if (glowColorSize == 0.0) {
      return 0.0;
    }

    // 将传入的指定距离，平均分成10圈，求出每一圈的平均透明度，
    // 然后求和取平均值，那么就可以得到该点的平均透明度
    float totalAlpha = 0.0;
    totalAlpha += getAverageAlpha(glowColorSize * 0.1);
    totalAlpha += getAverageAlpha(glowColorSize * 0.2);
    totalAlpha += getAverageAlpha(glowColorSize * 0.3);
    totalAlpha += getAverageAlpha(glowColorSize * 0.4);
    totalAlpha += getAverageAlpha(glowColorSize * 0.5);
    totalAlpha += getAverageAlpha(glowColorSize * 0.6);
    totalAlpha += getAverageAlpha(glowColorSize * 0.7);
    totalAlpha += getAverageAlpha(glowColorSize * 0.8);
    totalAlpha += getAverageAlpha(glowColorSize * 0.9);
    totalAlpha += getAverageAlpha(glowColorSize * 1.0);
    return totalAlpha * 0.1;
  }


  

  void main () {
    vec4 o = vec4(1, 1, 1, 1);

    #if USE_TEXTURE
      CCTexture(texture, v_uv0, o);
    #endif

    o *= v_color;
    ALPHA_TEST(o);

    #if USE_BGRA
      gl_FragColor = o.bgra;
    #else
      gl_FragColor = o.rgba;
    #endif

    float alpha = getGlowAlpha();
    if (alpha > glowThreshold) {
      // 内发光是从边缘发光的，是需要内部透明度为0，靠近边缘的接近1的透明度
      // 因此我们需要反转一下透明度
      alpha = 1.0 - alpha * alpha * alpha * alpha;
    }
    // o = glowColor * alpha;

    // 源颜色就是内发光颜色
    vec4 color_dest = o;

    // 目标颜色就是图案颜色色 
    
    vec4 color_src = glowColor * alpha;

    // 按照官方的混合颜色介绍和规则
    //
    // 要在图案上方，叠加一个内发光，将两者颜色混合起来，那么最终选择的混合模式如下：
    //
    // （内发光）color_src: GL_SRC_ALPHA
    // （原图像）color_dest: GL_ONE
    // 
    // 即最终颜色如下：
    // color_src * GL_SRC_ALPHA + color_dest * GL_ONE
    gl_FragColor = color_src  + color_dest;
    }
}%
