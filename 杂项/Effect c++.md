# Effect c++

客户（client）是指某人或某物。他使用你写的代码（通常是一些接口）。在某个时间点你几乎必然发现，你就你自己的客户。那个时候你很很高兴你在**开发接口时把客户放在心上**。

### 1. 视c++ 为一个语言联邦

1. c
2. object-oriented C++
3. Template c++
4. STL

### 2.尽量以const，enum，inline 替换#define 

1. 每个函数的声明揭示其签名式（signature），也就是参数和返回类型。

2. 如果编译器不允许“static 整数型class 常量”完成“in class ”初值设定。可以改用“the enum hack"补偿做法。

   ```c++
   class MyClass{
   	enum {
   		num = 6;
   	}
   	int m_scores[num];
       int m_a;
       char m_c;
   }
   ```

### 3.尽可能使用const

1. 两个函数如果只是常量（constness）不同，也可以被重载。
2. const 成员函数调用non-const成员函数是个糟糕的选择（const 承诺了不会改变其内部数据）。但反过来却可以。（通过两次转型动作）

### 4.确定对象被使用前已被初始化

1. 对象成员变量的初始化动作发生在进入构造函数前。

2. 推荐在构造函数时使用初始值列表**初始化**，而不是在构造函数里**赋值**。（同时初始值列表列出的成员变量，最好与他们在class中声明的顺序相同）

   ```c++
   MyClass::MyClass(int a,char c):m_a(a),m_c(c){}
   ```

3. 如果一个值是const或references,则必须使用初始值列表初始化。

4. non-local staic(extern 声明的变量）可能会有初始化顺序的问题。推荐使用local staic。 

### 5.了解c++默认编写并调用了哪些函数

1. 构造
2. 析构
3. 拷贝构造
4. 赋值构造  

### 6.若不想使用编译器自动生成的函数，就该明确拒绝

### 7.为多态基类声明virtual析构函数

1. 不是所有基类的设计都是为了多态，有可能是为了屏蔽拷贝构造函数（P39）

### 8.别让异常逃离析构函数(不甚理解)

1. `std::abort()`结束进程
2. 析构函数不应该抛出异常。可以选择捕捉他们然后当做没看见或者直接结束程序。`try{}catch(){}`
3. 如果客户需要对某个操作运行期间抛出异常做出反应，应该提供一个普通函数执行这个操作，而非放在析构函数中

### 9.绝不在构造函数和析构函数中调用virtual函数

### 10.令operator= 返回一个reference to *this

### 11.在operator= 中处理“自我赋值”

一般发生在一个类中有个类类型

1. 比较是否是同一地址
2. 合适的语句顺序
3. copy-and-swap(通过值传递和swap实现)

### 12.复制对象时勿忘记复制其每一个成分

1. 复制所有local 成员变量
2. 如果基类的拷贝函数是自己定义的，在子类中也请显示的调用他们。
3. 不要尝试拷贝构造和拷贝赋值互相调用。

### 13以对象管理资源

资源指的是，一旦你用了它，将来必须还给系统。比如说，内存，互斥锁，网络socket，数据库连接，以及图形界面中的字型和笔刷。（后面几个都不懂）



​        
