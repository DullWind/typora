# 答案版

## 数据结构

### 红黑树

1. 特性

   （1）每个节点或者是黑色，或者是红色。
   （2）根节点是黑色。
   （3）每个叶子节点（NIL）是黑色。  **[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
   （4）如果一个节点是红色的，则它的子节点必须是黑色的。**（不可能有两个连续的红色节点）**
   （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

2. 它是一棵接近平衡二叉树。

3. 添加操作

   1. 将红黑树当作一颗二叉查找树，将节点插入。
   2. 将插入的节点着色为"红色"。
   3. 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。
   4. ①  情况说明：被插入的节点是根节点。
      处理方法：直接把此节点涂为黑色。
      ②  情况说明：被插入的节点的父节点是黑色。
        处理方法：什么也不需要做。节点被插入后，仍然是红黑树。
      ③  情况说明：被插入的节点的父节点是红色。
          处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)

### 哈希表

1. 也叫散列表
2. 哈希函数 -- 除留余数法 
   - 取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。
3. 解决哈希冲突
   1. 开链法：将同一地址的数据建立一个链表
   2. 开发地址法：当关键字key的哈希地址p出现冲突时，就以p为基础再进行一次哈希。
   3. 再哈希法：当发生冲突时就用另一个函数。

# 数学

### 如何判断一个物体的方向

1.1.判断目标在自己的前后方位可以使用下面的方法:

   Vector3.Dot(transform.forward, target.position)

       返回值为正时,目标在自己的前方,反之在自己的后方

2.判断目标在机子的左右方位可以使用下面的方法:

   Vector3.Cross(transform.forward, target.position).y

      返回值为正时,目标在自己的右方,反之在自己的左方


3.在这里顺便解说下关于空间向量的点积和叉积:

A.点积 
  点积的计算方式为:  a·b=|a|·|b|cos<a,b>  其中|a|和|b|表示向量的模，<a,b>表示两个向量的夹角。另外在 点积 中，<a,b>和<b,a> 夹角是不分顺序的。 
  所以通过点积，我们其实是可以计算两个向量的夹角的。 
  另外通过点积的计算我们可以简单粗略的判断当前物体是否朝向另外一个物体: 只需要计算当前物体的transform.forward向量与 otherObj.transform.position 的点积即可， 大于0则在前方，否则在后方。

B.叉积 
  叉积的定义： c =a x b  其中a,b,c均为向量。即两个向量的叉积得到的还是向量！ 
  性质1： c⊥a，c⊥b，即向量c垂直与向量a,b所在的平面 。 
  性质2： 模长|c|=|a||b|sin<a,b> 
  性质3： 满足右手法则 。从这点我们有axb ≠ bxa，而axb = – bxa。所以我们可以使用叉积的正负值来判断向量a，b的相对位置，即向量b是处于向量a的顺时针方向还是逆时针方向

# 图形学

### 点到平面的距离如何计算

1. $$
   \frac{|Ax_1+By_1+Cz_1+D|}{\sqrt{A^2+B^2+C^2}}
   $$

### GPU渲染管线

1. 获取顶点坐标
2. mvp变化，将一个物业移到一个1 * 1 *1 的标准立方体内，将3维坐标转为2维坐标
3. 栅格化。（判断点是否在三角形内，并通过深度查询来着色）
4. 渲染（shader）（通过各种各样的模型来着色，phone，bulingPhone）
5. 输出图片

### 法线贴图

通过改变法线的位置，来影响光照模型，从而形成凹凸效果

### 光栅化

将几何数据经过一系列变换后最终转换为[像素](https://so.csdn.net/so/search?q=像素&spm=1001.2101.3001.7020)，从而呈现在显示设备上的过程

### 抗锯齿

MSAA：（这是一个模糊操作）将一个像素点拆分成更多的采样点（并不是增加采样率），然后判断哪些点在三角形内，哪些点在三角形外。然后进行颜色的处理。

### 圆上取三个点 三个点组成的三角形是锐角 直角 钝角三角形概率

1/4，0，3/4.

### 齐次坐标的好处

平移，选择，缩放，可以用一个矩阵来表示

### 旋转矩阵 -- 欧拉角--四元数

1. 旋转矩阵，一个点乘以旋转矩阵得到旋转过后的点

2. 欧拉角，任何一个旋转都可以表示为依次绕三个旋转轴旋转三次的角度。这个角度就是欧拉角

3. 四元数，任何一个旋转也可以表示为，绕三维空间中某一个旋转轴，旋转一次得到结果。优点：  非奇异表达（和欧拉角之类的表示相比），   比矩阵更紧凑（更快速）， 单位四元数的对可以表示四维空间中的一个旋转

### 点在三角形内

1. 将这个点，与三角形三个顶点连线。与三角形的三条边分别做叉乘，如果都是大于0，或者小于0则代表在三角形内。（判断在线的左边还是右边）

### 点在矩形内

1. 如果是aabb，直接判断是否同时大于一个点的x,y。小于它对角点的x,y。
2. 如果是obb，可以对四条边做叉乘，判断是否同时大于0，或者小于0。如果是则代表在三角形内。

### 点与线段的距离

![image-20220315145505192](https://gitee.com/MeguminMO/drawing-bed/raw/master//typora/202203151455835.png)

### 圆形与矩形是否有交点

1. 将直线方程带入圆的方程求交点，如果有交点，判断这个点是否在矩形上。

### 点与扇形求交

1. 判断点到扇形圆心的距离是否小于r，如果是再判断，点与扇形两边ab,ac俩边求叉乘，是否是一个大于0，一个小于0。

### 贝塞尔曲线

1. 这个曲线一定通过起点和终点
2. 找出这个曲线上的所有点，连起来就是一个曲线
3. 如果我们要取这个曲线的时间t的点
4. 我们可以连接每一个点，然后在线段取它相应比例上的点
5. 重复上面步骤直到只剩下一个点，这个点就算曲线上的点

### 已知二维平面一个圆形的运动速度和方向，是否会和另一个圆形碰撞，若碰撞，求出具体时间点。

1. 判断点到直线的距离是否小于两个圆的半径，如果小于则代表一定有交点。
2. 当点到直线的距离等于2r时，代表他们最先接触。这时，已知两个线度的长度和一个角。可以通过正弦定理（a/sinA = b/sinB = c/sinC）求的剩余的角，从而得到剩余的边。

###  怎么实现3d物体的描边

1. 基于轮廓边检测。 检查这条边相邻的两个三角面片是否满足：(n0·v > 0) ≠ (n1·v >  0)。这里n0和n1分别表示两个相邻三角面片的法向，v是从视角到该边上任意顶点的方向。本质是检查相邻两个三角是否一个面向视角，另一个背向视角。  可以控制轮廓线的风格渲染。缺点是轮廓是逐帧单独提取的，帧与帧之间会出现跳跃性。 

## unity

### monobehavior的生命周期函数，尽可能多的列举

Awake：当一个脚本实例被载入时Awake被调用。我们大多在这个类中完成成员变量的初始化
OnEnable：当对象变为可用或激活状态时此函数被调用。
Start：仅在Update函数第一次被调用前调用。因为它是在Awake之后被调用的，我们可以把一些需要依赖Awake的变量放在Start里面初始化。 同时我们还大多在这个类中执行StartCoroutine进行一些协程的触发。要注意在用C#写脚本时，必须使用StartCoroutine开始一个协程，但是如果使用的是JavaScript，则不需要这么做。
Update：当MonoBehaviour启用时，其Update在每一帧被调用。
FixedUpdate：当MonoBehaviour启用时，其 FixedUpdate 在每一固定帧被调用。
LateUpdat 方法 :是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现
OnGUI 方法:  渲染和处理GUI事件时调用 这里不是 没帧都调用哦
OnDisable：当对象变为不可用或非激活状态时此函数被调用。
OnDestroy：当MonoBehaviour将被销毁时，这个函数被调用。

### animation和animator的区别？为什么不选择用animation？

Animation控制一个动画播放的各类方法和数据（当然你可以通过修改目标动画进行动画切换）

Animator则可以实现控制多个动画的播放，切换，叠加等一级对骨骼动画控制等更复杂的效果，是一个动画[状态机]

### animator使用过吗？动画分层？动画融合？

 动画融合一般用于解决例如边跑边攻击的问题。简单说就是让跑步去控制腿的骨骼，攻击控制手的骨骼，两个动画融合在一起来播放。 



## 其它

###  **Drawcall** 

1. cpu提交数据给gpu，然后gpu下达渲染命令的这个过程
2. drawCall 数目：指的是游戏引擎绘制一个场景中的所有物体需要向gpu提交的渲染命令。
3. 合批（减少drawCall数目）：把几个物体合在一起提交给gpu渲染绘制叫做合批。 **所以合批提交渲染，能提升 GPU 的吞吐量，提高效率。** 
4. drawCall 导致的性能开销主要在cpu端的命令主装。

### 静态合批

1.  静态合批是将能够合批物体的网格按照它的位置预先重新合并生成一个大的新网格，然后进行绘制。

2. 坏处：

   1. 静态合批需要预先合并网格，增加了运行初始化的时间
   2. 可能会增大了内存开销
      1.  这里首先有「可能」两个字，也就是说某些情况下会增加，某些情况下不会增加。试想一下，如果100个物体完全不一样，那么合并后的 Mesh 顶点的内存开销和合并前都是一样的；但如果100个物体的 Mesh 完全一样，那么合并后就会有100个同一个 Mesh 不同位置的顶点数据了，这种合并就会增大内存开销。所以在实际游戏开发中，我们在做森林（大量相同树木）等场景时，就不使用静态合批。 
   3.  静态合批一但预先计算好合并后的网格，这些物体就不能再「移动」了 

### 动态合批

1.  动态合批是指在每次渲染之前，CPU 将能够合批的物体的每个顶点的世界坐标计算出来（模型顶点坐标*世界变化矩阵）后，提交给 GPU，然后世界矩阵用单位矩阵，来达到合批的效果。动态合批适合用于移动的物体，且不会产生额外的内存开销。 （不是很理解为什么这么做就能合批）

  

###  **GPU Instancing 合批** 

1. 原理： 对于游戏场景中同一个物体的 N 个实例可以采用 GPU Instancing 合批技术，它的原理是提交一次物体的模型，然后将实例的位置、旋转、缩放等信息提交给 GPU，再由 GPU 绘制 N 个实例出来 