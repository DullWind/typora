### TCP三次握手

1. 第一次握手：客户端发起请求，发送一个**SYN**给服务器端，并指明自身的**ISN**，自身进入SYN_send状态
2. 第二次握手：服务器端接受请求，以自身的**SYN**作为应答，将客户端的**ISN+ 1**作为ACK，以及自身的**ISN**信号，发回给客户端，自身进入syn_Recv状态
3. 第二次握手：客户端接收到SYN，同样发送一个**ACK**包（服务器端的ISN+1），表面自身已收到服务器端的SYN报文。自身进入establised状态
4. 服务器接收到ack包后进入establised 状态



### TCP四次挥手

1. 第一次挥手：客户端发送一个有指定自身序列号的FIN报文给客户端，自身进入closed_wait1状态。
2. 第二次挥手：服务器端收到FIN报文，将序列号+1，作为ACK返回给客户端，表面已收到客服端报文，自身进入closed_wait2状态。
3. 第三次挥手：服务器端向客户端发送FIN报文（同样有指定自身序列号），自身进入last_ack状态
4. 第四次挥手：客户端收到服务器端的FIN信号，将系列号+1，作为ACK返回给服务器端，自身进入time_wait状态，需要过一会才能进入close状态。
5. 服务器接收到ACK报文进入close状态。

Tip:第四次挥手为什么客户端发送完信号，进入的是time_wait.

A:因为客户端发送完报文后，并不知道服务器端是否正确接收到报文，如果服务器在一定时间内没接收到报文，会重新发送FIN报文。因此客户端需要等待一段时间，

### TCP和UDP的区别

**TCP：**

1. TCP是面向连接的运输层协议，面向连接指的是在双方通信前要建立连接。
2. 一条tcp只有两个端点。点-点
3. tcp提供可靠的传输服务，无差错，不丢失，不重复，按序到达。
4. tcp是双工通信，允许通信双方随时发送和接收信息，因为俩方都设有通信缓存和接收缓存
5. tcp是面向字节流，虽然应用程序和tcp交流时是通过数据块， 但tcp将其看成一连串无结构的字节流，它不保证发送方的数据块与接收方的数据块具有对应大小关系。
6. tcp使用慢开始，拥塞避免，快重传和快恢复来实现，拥塞控制避免网络拥塞。

**UDP：**

1. UDP是无连接的传输层协议。
2. UDP可以多对多
3. UDP尽最大努力交付但不保证准确性
4. UDP没有拥塞机制
5. UPD首部开销小只有8个字节，TCP20个字节

### OSI七层模型

1.应用层-表示层-会话层-运输层-网络层-数据链路层-物理层

### ARQ协议

1. 自动重传ARQ，指只要超过一段时间没有收到确认信息就重新发送上一次发送过的分组。因此每发送完一个分组设置一个重传计时器（一般计时器的时间比数据在分组传输往返的时间长一些），这种重传就叫做重传ARQ

2. 连续ARQ协议，提高信道利用率，发送方维持一个发送窗口，在发送窗口内的分组可以联系发送，而不用对方确认。接收方一般采用累计计数确认 ，对按序到达的最后一个分组确认，表明这个窗口的所有分组都已经收到。

### 拥塞控制

 拥塞控制是为了避免过多的数据注入到网络中，发送方要维护一个拥塞窗口（拥塞窗口取决于网络拥塞程度）发送方的发送窗口取拥塞窗口和接收窗口中较小的一个。

TCP拥塞控制采用了四种算法：

1. 慢启动，当主机一开始发送数据时，并不知道网络情况，所以最好先探测一下，由小到大增加拥塞窗口的数值。
2. 拥塞避免，让拥塞窗口缓慢增大，每经过一个往返时间就把发送方的拥塞窗口加1。
3. 快重传与快恢复（fast retransmit and recovery，FRR）：没有FRR的时候，如果数据发生了丢失，tcp会使用定时器来暂停传输。有了FRR，如果数据发送了丢失，发送方就会发送一个重复确认，如果接收方接收到三个重复确认，就会认为上一个数据发送失败，就会立即重传对方尚未接收的数据

