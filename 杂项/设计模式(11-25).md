# 设计模式（11-25）

## 抽象工厂

1. 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类

2. 有点：易于交换产品系列，它让具体的创建实例过程与客户端分离，客户端通过抽象接口操作实例，产品的具体类名也被具体工厂的实现分离。

3. 优化：可以将不同工厂的选择，使用简单工厂来代替。同时switch ，case 语句可以使用 反射来实现。

4. 代码：生成（便宜/昂贵）水果与（便宜/昂贵）饮料

   1. ```c++
      class FruitProduct {
      public:
      	string level;
      	void eat(){
      		cout << "吃" +this->level+ "水果" << endl;
      	}
      };
      class DrinkProduct {
      public:
      	string level;
      	void drink() {
      		cout << "喝" + this->level + "饮料" << endl;
      	}
      };
      
      class ExpensiveFruit : public FruitProduct {
      public:
      	ExpensiveFruit() {
      		this->level = "昂贵";
      	}
      };
      class CheapFruit : public FruitProduct {
      public:
      	CheapFruit() {
      		this->level = "便宜";
      	}
      };
      
      class ExpensiveDrink : public DrinkProduct {
      public:
      	ExpensiveDrink() {
      		this->level = "昂贵";
      	}
      };
      class CheapDrink : public DrinkProduct {
      public:
      	CheapDrink() {
      		this->level = "便宜";
      	}
      };
      
      
      class FactoryTemplate {
      public:
      	virtual FruitProduct* getFruit()  = 0;
      	virtual DrinkProduct* getDrink() = 0;
      };
      
      class HighFactory : public FactoryTemplate{
      	FruitProduct* getFruit() {
      		return new ExpensiveFruit();
      	}
      	DrinkProduct* getDrink() {
      		return new ExpensiveDrink();
      	}
      };
      
      class LowFactory : public FactoryTemplate {
      	FruitProduct* getFruit() {
      		return new CheapFruit();
      	}
      	DrinkProduct* getDrink() {
      		return new CheapDrink();
      	}
      };
      
      int main() {
      	FactoryTemplate* factory = new LowFactory();
      	//FactoryTemplate* factory = new HighFactory();
      	FruitProduct* fruit1 = factory->getFruit();
      	DrinkProduct* drink1 = factory->getDrink();
      	fruit1->eat();
      	drink1->drink();
      
      	return 0;
      }
      ```

      

## 状态模式

1. 定义：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

2. 优点：将与特定状态相关的行为局部化，并且将不同状态的行为分隔开来。

3. 代码：动画切换（状态机）(idle--run---attack)

   1. ```c++
      class Director;
      
      class State {
      public:
      	virtual void update(Director* dir) =0 ;
      };
      
      class Run : public State {
      public:
      	
      	void update(Director* dir);
      
      };
      
      class Idle : public State {
      public:
      	void update(Director* dir);
      };
      
      
      
      class Attack : public State {
      public:
      	void update(Director* dir);
      };
      
      class Director {
      public:
      	State* curState;
      	string keyCode;
      	Director() {
      		this->curState = new Idle();
      	}
      	void setState(State* s) {
      		this->curState = s;
      	}
      	void update() {
      		this->curState->update(this);
      	}
      };
      
      void Run::update(Director* dir) {
      	cout << "播放跑步动画中" << endl;
      	if (dir->keyCode == "攻击") {
      		dir->setState(new Attack());
      	}
      }
      
      void Idle::update(Director* dir) {
      	cout << "播放待机动画中" << endl;
      	if (dir->keyCode == "跑") {
      		dir->setState(new Run());
      	}
      }
      
      void Attack::update(Director* dir) {
      	cout << "播放攻击动画中" << endl;
      	if (dir->keyCode == "待机") {
      		dir->setState(new Idle());
      	}
      }
      
      
      int main() {
      	Director* dir = new Director();
      	dir->update();
      	dir->update();
      	dir->keyCode = "攻击";
      	dir->update();
      	dir->update();
      	dir->update();
      	dir->keyCode = "跑";
      	dir->update();
      	dir->update();
      	dir->update();
      	dir->keyCode = "攻击";
      	dir->update();
      	dir->update();
      	dir->keyCode = "待机";
      	dir->update();
      	dir->update();
      
      	return 0;
      }
      ```

      

## 适配器模式

1. 定义：当系统的行为和数据都正确，但接口不符时，我们应该考虑用适配器，使控制范围之外的一个原有对象与某个接口匹配。
2. 目的：主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况
3. 代码：懒，不想写，自己看UML
   - ![image-20211104102634939](C:\Users\wuyuzhen02\Desktop\typora\杂项\图片\image-20211104102634939.png)

## 备忘录模式

1. 定义： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可将这个对象恢复到原先保存的状态。

2. 作用：当角色的状态改变时，有可能这个状态无效，这时就可以使用暂时存储起来的备忘录将状态复原。

3. 代码：游戏角色存档

   ```c++
   class Archive {
   public:
   	int hp;
   	int mp;
   	Archive(int hp, int mp) {
   		this->hp = hp;
   		this->mp = mp;
   	}
   };
   
   class Player {
   public:
   	int hp;
   	int mp;
   
   	Archive* saveArchive() {
   		return new Archive(hp,mp);
   	}
   
   	void recoverArchive(Archive* arc) {
   		this->hp = arc->hp;
   		this->mp = arc->mp;
   	}
   
   	void show() {
   		cout << "hp" << hp << endl;
   		cout << "mp:" << mp << endl;
   		cout << "---------" << endl;
   	}
   };
   
   class ArchiveMgr {
   public:
   	Archive* archive;
   };
   
   
   int main() {
   	Player* player = new Player();
   	player->hp = 100;
   	player->mp = 100;
   	player->show();
   
   	ArchiveMgr* archiveMgr = new ArchiveMgr();
   	archiveMgr->archive = player->saveArchive();
   	player->mp = 32;
   	player->hp = 22;
   	player->show();
   
   	player->recoverArchive(archiveMgr->archive);
   	player->show();
   	return 0;
   }
   ```

   

## 组合模式

1. 定义：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性

2. 作用：当需求中是体现部分与整体层次的结构时，以及用户可以忽略组合对象与单个对象的不同，统一的使用组合结构中的所有对象时，就应该考虑使用组合模式。

3. 代码：给字符串加粗 

   1. ```c++
      class Component {
      public:
      	string str;
      	virtual void add(Component*) {};
      	virtual void remove(Component*) {};
      	virtual void bold() {};
      	virtual void setStr(string str) {
      		this->str = str;
      	}
      };
      
      class Branch : public Component {
      public:
      	list<Component*> children ;
      	void add(Component* com) {
      		children.push_back(com);
      	}
      	void remove(Component* com) {
      		children.remove(com);
      	}
      	void bold() {
      		cout << this->str << "------已经加粗" << endl;
      		for (auto child : children) {
      			child->bold();
      		}
      	}
      };
      
      class Leaf : public Component {
      	void bold() {
      		cout << this->str << "------已经加粗" << endl;
      	}
      };
      
      
      int main() {
      	Component* root = new Branch();
      	root->setStr("整个字符串");
      	Component* nh = new Branch();
      	nh->setStr("你好");
      	Component* s = new Leaf();
      	s->setStr("世");
      	Component* j = new Leaf();
      	j->setStr("界");
      	Component* temp = new Leaf();
      	temp->setStr("hhh");
      
      	root->add(nh);
      	nh->add(s);
      	nh->add(j);
      	nh->add(temp);
      	nh->remove(temp);
      	root->bold();
      	return 0;
      }
      ```

      

## 迭代器模式

1. 定义：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象
2. 作用：分离了集合对象的遍历行为。

### 不会写

1. 代码：list 迭代器（不会写/(ㄒoㄒ)/~~）

## 单例模式

1. 定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点

2. 代码：多线程单例（懒汉式）

   1. ```c++
      mutex m;
      class CA {
      private:
      	static CA* _instance;
      	CA() {};
      public:
      	static CA* getInstance() {
      		if (_instance == nullptr) {
      			m.lock();
      			if (_instance == nullptr) {
      				_instance = new CA();
      			}
      			m.unlock();
      		}
      		return _instance;
      	}
      
      	void show() {
      		cout << "hello word" << endl;
      	}
      };
      
      CA* CA::_instance = nullptr;
      
      
      int main() {
      	CA* ca = CA::getInstance();
      	ca->show();
      	return 0;
      }
      ```

## 桥接模式

1. 定义：将抽象部分与它的实现部分分离，使他们可以独立的变化。

2. 优点：降低耦合

3. UML：![image-20211104165154571](C:\Users\wuyuzhen02\Desktop\typora\杂项\图片\image-20211104165154571.png)

4. 代码：手机软件运行

   1. ```c++
      class SoftWare {
      public:
      	virtual void run() = 0;
      };
      
      
      class Phone {
      	SoftWare* softWare;
      public:
      	void play() {
      		this->softWare->run();
      	}
      	void setSoftWare(SoftWare* sw) {
      		this->softWare = sw;
      	}
      };
      
      class Apple : public Phone {
      	string name;
      };
      
      class Game : public SoftWare {
      	void run() {
      		cout << "运行游戏" << endl;
      	}
      };
      
      class Letter : public SoftWare {
      	void run() {
      		cout << "写信" << endl;
      	}
      };
      
      int main() {
      
      	Apple* a = new Apple();
      	Letter* l = new Letter();
      	Game* g = new Game();
      	a->setSoftWare(l);
      	a->play();
      	a->setSoftWare(g);
      	a->play();
      	return 0;
      }
      ```

      

## 命令模式

1. 定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；请求排队或者记录请求日志，以及支持可撤销的操作

